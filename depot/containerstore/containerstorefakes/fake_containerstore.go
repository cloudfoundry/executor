// Code generated by counterfeiter. DO NOT EDIT.
package containerstorefakes

import (
	"io"
	"sync"

	"code.cloudfoundry.org/executor"
	"code.cloudfoundry.org/executor/depot/containerstore"
	"code.cloudfoundry.org/lager"
	"github.com/tedsuo/ifrit"
)

type FakeContainerStore struct {
	CleanupStub        func(lager.Logger)
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct {
		arg1 lager.Logger
	}
	CreateStub        func(lager.Logger, string) (executor.Container, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	createReturns struct {
		result1 executor.Container
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 executor.Container
		result2 error
	}
	DestroyStub        func(lager.Logger, string) error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	destroyReturns struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(lager.Logger, string) (executor.Container, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	getReturns struct {
		result1 executor.Container
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 executor.Container
		result2 error
	}
	GetFilesStub        func(lager.Logger, string, string) (io.ReadCloser, error)
	getFilesMutex       sync.RWMutex
	getFilesArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	getFilesReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	getFilesReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	InitializeStub        func(lager.Logger, *executor.RunRequest) error
	initializeMutex       sync.RWMutex
	initializeArgsForCall []struct {
		arg1 lager.Logger
		arg2 *executor.RunRequest
	}
	initializeReturns struct {
		result1 error
	}
	initializeReturnsOnCall map[int]struct {
		result1 error
	}
	ListStub        func(lager.Logger) []executor.Container
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 lager.Logger
	}
	listReturns struct {
		result1 []executor.Container
	}
	listReturnsOnCall map[int]struct {
		result1 []executor.Container
	}
	MetricsStub        func(lager.Logger) (map[string]executor.ContainerMetrics, error)
	metricsMutex       sync.RWMutex
	metricsArgsForCall []struct {
		arg1 lager.Logger
	}
	metricsReturns struct {
		result1 map[string]executor.ContainerMetrics
		result2 error
	}
	metricsReturnsOnCall map[int]struct {
		result1 map[string]executor.ContainerMetrics
		result2 error
	}
	NewContainerReaperStub        func(lager.Logger) ifrit.Runner
	newContainerReaperMutex       sync.RWMutex
	newContainerReaperArgsForCall []struct {
		arg1 lager.Logger
	}
	newContainerReaperReturns struct {
		result1 ifrit.Runner
	}
	newContainerReaperReturnsOnCall map[int]struct {
		result1 ifrit.Runner
	}
	NewRegistryPrunerStub        func(lager.Logger) ifrit.Runner
	newRegistryPrunerMutex       sync.RWMutex
	newRegistryPrunerArgsForCall []struct {
		arg1 lager.Logger
	}
	newRegistryPrunerReturns struct {
		result1 ifrit.Runner
	}
	newRegistryPrunerReturnsOnCall map[int]struct {
		result1 ifrit.Runner
	}
	RemainingResourcesStub        func(lager.Logger) executor.ExecutorResources
	remainingResourcesMutex       sync.RWMutex
	remainingResourcesArgsForCall []struct {
		arg1 lager.Logger
	}
	remainingResourcesReturns struct {
		result1 executor.ExecutorResources
	}
	remainingResourcesReturnsOnCall map[int]struct {
		result1 executor.ExecutorResources
	}
	ReserveStub        func(lager.Logger, *executor.AllocationRequest) (executor.Container, error)
	reserveMutex       sync.RWMutex
	reserveArgsForCall []struct {
		arg1 lager.Logger
		arg2 *executor.AllocationRequest
	}
	reserveReturns struct {
		result1 executor.Container
		result2 error
	}
	reserveReturnsOnCall map[int]struct {
		result1 executor.Container
		result2 error
	}
	RunStub        func(lager.Logger, string) error
	runMutex       sync.RWMutex
	runArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	runReturns struct {
		result1 error
	}
	runReturnsOnCall map[int]struct {
		result1 error
	}
	StopStub        func(lager.Logger, string) error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	stopReturns struct {
		result1 error
	}
	stopReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateStub        func(lager.Logger, *executor.UpdateRequest) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 lager.Logger
		arg2 *executor.UpdateRequest
	}
	updateReturns struct {
		result1 error
	}
	updateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContainerStore) Cleanup(arg1 lager.Logger) {
	fake.cleanupMutex.Lock()
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.CleanupStub
	fake.recordInvocation("Cleanup", []interface{}{arg1})
	fake.cleanupMutex.Unlock()
	if stub != nil {
		fake.CleanupStub(arg1)
	}
}

func (fake *FakeContainerStore) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *FakeContainerStore) CleanupCalls(stub func(lager.Logger)) {
	fake.cleanupMutex.Lock()
	defer fake.cleanupMutex.Unlock()
	fake.CleanupStub = stub
}

func (fake *FakeContainerStore) CleanupArgsForCall(i int) lager.Logger {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	argsForCall := fake.cleanupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerStore) Create(arg1 lager.Logger, arg2 string) (executor.Container, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerStore) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeContainerStore) CreateCalls(stub func(lager.Logger, string) (executor.Container, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeContainerStore) CreateArgsForCall(i int) (lager.Logger, string) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerStore) CreateReturns(result1 executor.Container, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 executor.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerStore) CreateReturnsOnCall(i int, result1 executor.Container, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 executor.Container
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 executor.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerStore) Destroy(arg1 lager.Logger, arg2 string) error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.DestroyStub
	fakeReturns := fake.destroyReturns
	fake.recordInvocation("Destroy", []interface{}{arg1, arg2})
	fake.destroyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContainerStore) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeContainerStore) DestroyCalls(stub func(lager.Logger, string) error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = stub
}

func (fake *FakeContainerStore) DestroyArgsForCall(i int) (lager.Logger, string) {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	argsForCall := fake.destroyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerStore) DestroyReturns(result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerStore) DestroyReturnsOnCall(i int, result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerStore) Get(arg1 lager.Logger, arg2 string) (executor.Container, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1, arg2})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerStore) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeContainerStore) GetCalls(stub func(lager.Logger, string) (executor.Container, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeContainerStore) GetArgsForCall(i int) (lager.Logger, string) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerStore) GetReturns(result1 executor.Container, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 executor.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerStore) GetReturnsOnCall(i int, result1 executor.Container, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 executor.Container
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 executor.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerStore) GetFiles(arg1 lager.Logger, arg2 string, arg3 string) (io.ReadCloser, error) {
	fake.getFilesMutex.Lock()
	ret, specificReturn := fake.getFilesReturnsOnCall[len(fake.getFilesArgsForCall)]
	fake.getFilesArgsForCall = append(fake.getFilesArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetFilesStub
	fakeReturns := fake.getFilesReturns
	fake.recordInvocation("GetFiles", []interface{}{arg1, arg2, arg3})
	fake.getFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerStore) GetFilesCallCount() int {
	fake.getFilesMutex.RLock()
	defer fake.getFilesMutex.RUnlock()
	return len(fake.getFilesArgsForCall)
}

func (fake *FakeContainerStore) GetFilesCalls(stub func(lager.Logger, string, string) (io.ReadCloser, error)) {
	fake.getFilesMutex.Lock()
	defer fake.getFilesMutex.Unlock()
	fake.GetFilesStub = stub
}

func (fake *FakeContainerStore) GetFilesArgsForCall(i int) (lager.Logger, string, string) {
	fake.getFilesMutex.RLock()
	defer fake.getFilesMutex.RUnlock()
	argsForCall := fake.getFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeContainerStore) GetFilesReturns(result1 io.ReadCloser, result2 error) {
	fake.getFilesMutex.Lock()
	defer fake.getFilesMutex.Unlock()
	fake.GetFilesStub = nil
	fake.getFilesReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerStore) GetFilesReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.getFilesMutex.Lock()
	defer fake.getFilesMutex.Unlock()
	fake.GetFilesStub = nil
	if fake.getFilesReturnsOnCall == nil {
		fake.getFilesReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.getFilesReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerStore) Initialize(arg1 lager.Logger, arg2 *executor.RunRequest) error {
	fake.initializeMutex.Lock()
	ret, specificReturn := fake.initializeReturnsOnCall[len(fake.initializeArgsForCall)]
	fake.initializeArgsForCall = append(fake.initializeArgsForCall, struct {
		arg1 lager.Logger
		arg2 *executor.RunRequest
	}{arg1, arg2})
	stub := fake.InitializeStub
	fakeReturns := fake.initializeReturns
	fake.recordInvocation("Initialize", []interface{}{arg1, arg2})
	fake.initializeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContainerStore) InitializeCallCount() int {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	return len(fake.initializeArgsForCall)
}

func (fake *FakeContainerStore) InitializeCalls(stub func(lager.Logger, *executor.RunRequest) error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = stub
}

func (fake *FakeContainerStore) InitializeArgsForCall(i int) (lager.Logger, *executor.RunRequest) {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	argsForCall := fake.initializeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerStore) InitializeReturns(result1 error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = nil
	fake.initializeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerStore) InitializeReturnsOnCall(i int, result1 error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = nil
	if fake.initializeReturnsOnCall == nil {
		fake.initializeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initializeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerStore) List(arg1 lager.Logger) []executor.Container {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.ListStub
	fakeReturns := fake.listReturns
	fake.recordInvocation("List", []interface{}{arg1})
	fake.listMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContainerStore) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeContainerStore) ListCalls(stub func(lager.Logger) []executor.Container) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakeContainerStore) ListArgsForCall(i int) lager.Logger {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerStore) ListReturns(result1 []executor.Container) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []executor.Container
	}{result1}
}

func (fake *FakeContainerStore) ListReturnsOnCall(i int, result1 []executor.Container) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 []executor.Container
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 []executor.Container
	}{result1}
}

func (fake *FakeContainerStore) Metrics(arg1 lager.Logger) (map[string]executor.ContainerMetrics, error) {
	fake.metricsMutex.Lock()
	ret, specificReturn := fake.metricsReturnsOnCall[len(fake.metricsArgsForCall)]
	fake.metricsArgsForCall = append(fake.metricsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.MetricsStub
	fakeReturns := fake.metricsReturns
	fake.recordInvocation("Metrics", []interface{}{arg1})
	fake.metricsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerStore) MetricsCallCount() int {
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	return len(fake.metricsArgsForCall)
}

func (fake *FakeContainerStore) MetricsCalls(stub func(lager.Logger) (map[string]executor.ContainerMetrics, error)) {
	fake.metricsMutex.Lock()
	defer fake.metricsMutex.Unlock()
	fake.MetricsStub = stub
}

func (fake *FakeContainerStore) MetricsArgsForCall(i int) lager.Logger {
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	argsForCall := fake.metricsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerStore) MetricsReturns(result1 map[string]executor.ContainerMetrics, result2 error) {
	fake.metricsMutex.Lock()
	defer fake.metricsMutex.Unlock()
	fake.MetricsStub = nil
	fake.metricsReturns = struct {
		result1 map[string]executor.ContainerMetrics
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerStore) MetricsReturnsOnCall(i int, result1 map[string]executor.ContainerMetrics, result2 error) {
	fake.metricsMutex.Lock()
	defer fake.metricsMutex.Unlock()
	fake.MetricsStub = nil
	if fake.metricsReturnsOnCall == nil {
		fake.metricsReturnsOnCall = make(map[int]struct {
			result1 map[string]executor.ContainerMetrics
			result2 error
		})
	}
	fake.metricsReturnsOnCall[i] = struct {
		result1 map[string]executor.ContainerMetrics
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerStore) NewContainerReaper(arg1 lager.Logger) ifrit.Runner {
	fake.newContainerReaperMutex.Lock()
	ret, specificReturn := fake.newContainerReaperReturnsOnCall[len(fake.newContainerReaperArgsForCall)]
	fake.newContainerReaperArgsForCall = append(fake.newContainerReaperArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.NewContainerReaperStub
	fakeReturns := fake.newContainerReaperReturns
	fake.recordInvocation("NewContainerReaper", []interface{}{arg1})
	fake.newContainerReaperMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContainerStore) NewContainerReaperCallCount() int {
	fake.newContainerReaperMutex.RLock()
	defer fake.newContainerReaperMutex.RUnlock()
	return len(fake.newContainerReaperArgsForCall)
}

func (fake *FakeContainerStore) NewContainerReaperCalls(stub func(lager.Logger) ifrit.Runner) {
	fake.newContainerReaperMutex.Lock()
	defer fake.newContainerReaperMutex.Unlock()
	fake.NewContainerReaperStub = stub
}

func (fake *FakeContainerStore) NewContainerReaperArgsForCall(i int) lager.Logger {
	fake.newContainerReaperMutex.RLock()
	defer fake.newContainerReaperMutex.RUnlock()
	argsForCall := fake.newContainerReaperArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerStore) NewContainerReaperReturns(result1 ifrit.Runner) {
	fake.newContainerReaperMutex.Lock()
	defer fake.newContainerReaperMutex.Unlock()
	fake.NewContainerReaperStub = nil
	fake.newContainerReaperReturns = struct {
		result1 ifrit.Runner
	}{result1}
}

func (fake *FakeContainerStore) NewContainerReaperReturnsOnCall(i int, result1 ifrit.Runner) {
	fake.newContainerReaperMutex.Lock()
	defer fake.newContainerReaperMutex.Unlock()
	fake.NewContainerReaperStub = nil
	if fake.newContainerReaperReturnsOnCall == nil {
		fake.newContainerReaperReturnsOnCall = make(map[int]struct {
			result1 ifrit.Runner
		})
	}
	fake.newContainerReaperReturnsOnCall[i] = struct {
		result1 ifrit.Runner
	}{result1}
}

func (fake *FakeContainerStore) NewRegistryPruner(arg1 lager.Logger) ifrit.Runner {
	fake.newRegistryPrunerMutex.Lock()
	ret, specificReturn := fake.newRegistryPrunerReturnsOnCall[len(fake.newRegistryPrunerArgsForCall)]
	fake.newRegistryPrunerArgsForCall = append(fake.newRegistryPrunerArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.NewRegistryPrunerStub
	fakeReturns := fake.newRegistryPrunerReturns
	fake.recordInvocation("NewRegistryPruner", []interface{}{arg1})
	fake.newRegistryPrunerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContainerStore) NewRegistryPrunerCallCount() int {
	fake.newRegistryPrunerMutex.RLock()
	defer fake.newRegistryPrunerMutex.RUnlock()
	return len(fake.newRegistryPrunerArgsForCall)
}

func (fake *FakeContainerStore) NewRegistryPrunerCalls(stub func(lager.Logger) ifrit.Runner) {
	fake.newRegistryPrunerMutex.Lock()
	defer fake.newRegistryPrunerMutex.Unlock()
	fake.NewRegistryPrunerStub = stub
}

func (fake *FakeContainerStore) NewRegistryPrunerArgsForCall(i int) lager.Logger {
	fake.newRegistryPrunerMutex.RLock()
	defer fake.newRegistryPrunerMutex.RUnlock()
	argsForCall := fake.newRegistryPrunerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerStore) NewRegistryPrunerReturns(result1 ifrit.Runner) {
	fake.newRegistryPrunerMutex.Lock()
	defer fake.newRegistryPrunerMutex.Unlock()
	fake.NewRegistryPrunerStub = nil
	fake.newRegistryPrunerReturns = struct {
		result1 ifrit.Runner
	}{result1}
}

func (fake *FakeContainerStore) NewRegistryPrunerReturnsOnCall(i int, result1 ifrit.Runner) {
	fake.newRegistryPrunerMutex.Lock()
	defer fake.newRegistryPrunerMutex.Unlock()
	fake.NewRegistryPrunerStub = nil
	if fake.newRegistryPrunerReturnsOnCall == nil {
		fake.newRegistryPrunerReturnsOnCall = make(map[int]struct {
			result1 ifrit.Runner
		})
	}
	fake.newRegistryPrunerReturnsOnCall[i] = struct {
		result1 ifrit.Runner
	}{result1}
}

func (fake *FakeContainerStore) RemainingResources(arg1 lager.Logger) executor.ExecutorResources {
	fake.remainingResourcesMutex.Lock()
	ret, specificReturn := fake.remainingResourcesReturnsOnCall[len(fake.remainingResourcesArgsForCall)]
	fake.remainingResourcesArgsForCall = append(fake.remainingResourcesArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.RemainingResourcesStub
	fakeReturns := fake.remainingResourcesReturns
	fake.recordInvocation("RemainingResources", []interface{}{arg1})
	fake.remainingResourcesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContainerStore) RemainingResourcesCallCount() int {
	fake.remainingResourcesMutex.RLock()
	defer fake.remainingResourcesMutex.RUnlock()
	return len(fake.remainingResourcesArgsForCall)
}

func (fake *FakeContainerStore) RemainingResourcesCalls(stub func(lager.Logger) executor.ExecutorResources) {
	fake.remainingResourcesMutex.Lock()
	defer fake.remainingResourcesMutex.Unlock()
	fake.RemainingResourcesStub = stub
}

func (fake *FakeContainerStore) RemainingResourcesArgsForCall(i int) lager.Logger {
	fake.remainingResourcesMutex.RLock()
	defer fake.remainingResourcesMutex.RUnlock()
	argsForCall := fake.remainingResourcesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerStore) RemainingResourcesReturns(result1 executor.ExecutorResources) {
	fake.remainingResourcesMutex.Lock()
	defer fake.remainingResourcesMutex.Unlock()
	fake.RemainingResourcesStub = nil
	fake.remainingResourcesReturns = struct {
		result1 executor.ExecutorResources
	}{result1}
}

func (fake *FakeContainerStore) RemainingResourcesReturnsOnCall(i int, result1 executor.ExecutorResources) {
	fake.remainingResourcesMutex.Lock()
	defer fake.remainingResourcesMutex.Unlock()
	fake.RemainingResourcesStub = nil
	if fake.remainingResourcesReturnsOnCall == nil {
		fake.remainingResourcesReturnsOnCall = make(map[int]struct {
			result1 executor.ExecutorResources
		})
	}
	fake.remainingResourcesReturnsOnCall[i] = struct {
		result1 executor.ExecutorResources
	}{result1}
}

func (fake *FakeContainerStore) Reserve(arg1 lager.Logger, arg2 *executor.AllocationRequest) (executor.Container, error) {
	fake.reserveMutex.Lock()
	ret, specificReturn := fake.reserveReturnsOnCall[len(fake.reserveArgsForCall)]
	fake.reserveArgsForCall = append(fake.reserveArgsForCall, struct {
		arg1 lager.Logger
		arg2 *executor.AllocationRequest
	}{arg1, arg2})
	stub := fake.ReserveStub
	fakeReturns := fake.reserveReturns
	fake.recordInvocation("Reserve", []interface{}{arg1, arg2})
	fake.reserveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerStore) ReserveCallCount() int {
	fake.reserveMutex.RLock()
	defer fake.reserveMutex.RUnlock()
	return len(fake.reserveArgsForCall)
}

func (fake *FakeContainerStore) ReserveCalls(stub func(lager.Logger, *executor.AllocationRequest) (executor.Container, error)) {
	fake.reserveMutex.Lock()
	defer fake.reserveMutex.Unlock()
	fake.ReserveStub = stub
}

func (fake *FakeContainerStore) ReserveArgsForCall(i int) (lager.Logger, *executor.AllocationRequest) {
	fake.reserveMutex.RLock()
	defer fake.reserveMutex.RUnlock()
	argsForCall := fake.reserveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerStore) ReserveReturns(result1 executor.Container, result2 error) {
	fake.reserveMutex.Lock()
	defer fake.reserveMutex.Unlock()
	fake.ReserveStub = nil
	fake.reserveReturns = struct {
		result1 executor.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerStore) ReserveReturnsOnCall(i int, result1 executor.Container, result2 error) {
	fake.reserveMutex.Lock()
	defer fake.reserveMutex.Unlock()
	fake.ReserveStub = nil
	if fake.reserveReturnsOnCall == nil {
		fake.reserveReturnsOnCall = make(map[int]struct {
			result1 executor.Container
			result2 error
		})
	}
	fake.reserveReturnsOnCall[i] = struct {
		result1 executor.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerStore) Run(arg1 lager.Logger, arg2 string) error {
	fake.runMutex.Lock()
	ret, specificReturn := fake.runReturnsOnCall[len(fake.runArgsForCall)]
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.RunStub
	fakeReturns := fake.runReturns
	fake.recordInvocation("Run", []interface{}{arg1, arg2})
	fake.runMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContainerStore) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeContainerStore) RunCalls(stub func(lager.Logger, string) error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = stub
}

func (fake *FakeContainerStore) RunArgsForCall(i int) (lager.Logger, string) {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	argsForCall := fake.runArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerStore) RunReturns(result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerStore) RunReturnsOnCall(i int, result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	if fake.runReturnsOnCall == nil {
		fake.runReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerStore) Stop(arg1 lager.Logger, arg2 string) error {
	fake.stopMutex.Lock()
	ret, specificReturn := fake.stopReturnsOnCall[len(fake.stopArgsForCall)]
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.StopStub
	fakeReturns := fake.stopReturns
	fake.recordInvocation("Stop", []interface{}{arg1, arg2})
	fake.stopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContainerStore) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeContainerStore) StopCalls(stub func(lager.Logger, string) error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = stub
}

func (fake *FakeContainerStore) StopArgsForCall(i int) (lager.Logger, string) {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	argsForCall := fake.stopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerStore) StopReturns(result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerStore) StopReturnsOnCall(i int, result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	if fake.stopReturnsOnCall == nil {
		fake.stopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerStore) Update(arg1 lager.Logger, arg2 *executor.UpdateRequest) error {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 lager.Logger
		arg2 *executor.UpdateRequest
	}{arg1, arg2})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContainerStore) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeContainerStore) UpdateCalls(stub func(lager.Logger, *executor.UpdateRequest) error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeContainerStore) UpdateArgsForCall(i int) (lager.Logger, *executor.UpdateRequest) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerStore) UpdateReturns(result1 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerStore) UpdateReturnsOnCall(i int, result1 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getFilesMutex.RLock()
	defer fake.getFilesMutex.RUnlock()
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	fake.newContainerReaperMutex.RLock()
	defer fake.newContainerReaperMutex.RUnlock()
	fake.newRegistryPrunerMutex.RLock()
	defer fake.newRegistryPrunerMutex.RUnlock()
	fake.remainingResourcesMutex.RLock()
	defer fake.remainingResourcesMutex.RUnlock()
	fake.reserveMutex.RLock()
	defer fake.reserveMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeContainerStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ containerstore.ContainerStore = new(FakeContainerStore)
